<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <title>–û–±—Ä–∞—Ç–∏ –ø—Ä–∏—Å—Ç—Ä–æ—ó</title>
</head>
<body>
<div id="device-selection">

    <h1>üéõ –í–∏–±–µ—Ä—ñ—Ç—å –≤—Ö—ñ–¥–Ω–∏–π —Ç–∞ –≤–∏—Ö—ñ–¥–Ω–∏–π –ø—Ä–∏—Å—Ç—Ä–æ—ó</h1>

    <div>
        <label for="inputSelect">–í—Ö—ñ–¥:</label>
        <select id="inputSelect"></select>
    </div>

    <div>
        <label for="outputSelect">–í–∏—Ö—ñ–¥:</label>
        <select id="outputSelect"></select>
    </div>

    <button id="startBtn">‚úÖ –ü–æ—á–∞—Ç–∏</button>
</div>
<select id="effectsDropdown">
    <option value="">–í–∏–±–µ—Ä—ñ—Ç—å –µ—Ñ–µ–∫—Ç</option>
</select>

<!-- –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –¥–æ–¥–∞–Ω–∏—Ö –µ—Ñ–µ–∫—Ç—ñ–≤ -->
<div id="activeEffectsContainer"></div>

<script>
    const apiBase = 'http://localhost:3000';

    const inputSelect = document.getElementById('inputSelect');
    const outputSelect = document.getElementById('outputSelect');
    const startBtn = document.getElementById('startBtn');

    const effectSelect = document.getElementById("effectsDropdown");
    const effectsContainer = document.getElementById("activeEffectsContainer");
    let availableEffects = [];

    let socket;
    // ‚è© –†–µ–¥—ñ—Ä–µ–∫—Ç –ø—ñ—Å–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü—ñ—ó
    window.onload = async function () {
        const token = localStorage.getItem('token');
        if (!token) {
            alert("–°–ø–æ—á–∞—Ç–∫—É –∞–≤—Ç–æ—Ä–∏–∑—É–π—Ç–µ—Å—å");
            location.href = '/client/auth';
            return;
        }

        const res = await fetch(`${apiBase}/devices`, {
            headers: {
                'Authorization': `${token}`
            }
        });

        if (!res.ok) {
            alert("–ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ –ø—Ä–∏—Å—Ç—Ä–æ—ó");
            return;
        }

        const devices = await res.json();

        const inputDevices = devices.filter(d => d.type === 0);
        const outputDevices = devices.filter(d => d.type === 1);

        inputDevices.forEach(dev => {
            const opt = document.createElement('option');
            opt.value = JSON.stringify(dev);
            opt.textContent = `${dev.name} [${dev.sampleRate}Hz] ${dev.hostApiName}`;
            inputSelect.appendChild(opt);
        });

        outputDevices.forEach(dev => {
            const opt = document.createElement('option');
            opt.value = JSON.stringify(dev);
            opt.textContent = `${dev.name} [${dev.sampleRate}Hz] ${dev.hostApiName}`;
            outputSelect.appendChild(opt);
        });
    };

    startBtn.onclick = async () => {
        const input = JSON.parse(inputSelect.value);
        const output = JSON.parse(outputSelect.value);

        if (input.sampleRate !== output.sampleRate || input.sampleRate !== output.sampleRate) {
            alert("‚ö†Ô∏è –í—Ö—ñ–¥ —ñ –≤–∏—Ö—ñ–¥ –º–∞—é—Ç—å –æ–¥–Ω–∞–∫–æ–≤–∏–π SampleRate —ñ HostApiName");
            return;
        }

        const body = {
            device1Index: input.index,
            device2Index: output.index,
            sampleRate: output.sampleRate,
            bufferSize: 32
        };

        const token = localStorage.getItem('token');

        await fetch('http://localhost:3000/ws', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `${token}`
            },
            body: JSON.stringify(body)
        });

        socket = new WebSocket(`ws://localhost:3000/ws?token=${token}`);

        socket.addEventListener("open", () => {
            console.log("WS connected");
            socket.send(JSON.stringify({type: "effects_list"}));
        });

        socket.onmessage = (event) => {
            const message = JSON.parse(event.data);

            switch (message.type) {
                case "effect_list_response":
                    availableEffects = message.data;
                    fillEffectDropdown();
                    break;
                case "effect_added":
                    renderEffect(message); // —Å–µ—Ä–≤–µ—Ä –º–æ–∂–µ –Ω–∞–¥—Å–∏–ª–∞—Ç–∏ effect –ø—ñ—Å–ª—è –¥–æ–¥–∞–≤–∞–Ω–Ω—è
                    break;
                default:
                    console.warn("Unknown message type", message);
            }
        };

        socket.addEventListener("error", (err) => {
            console.error("WebSocket error", err);
        });

        socket.addEventListener("close", () => {
            console.log("WebSocket closed");
        });

    };

    function fillEffectDropdown() {
        availableEffects.forEach(effect => {
            const option = document.createElement("option");
            option.value = effect.slug;
            option.textContent = effect.name ? effect.name : effect.slug;
            effectSelect.appendChild(option);
        });

        effectSelect.onchange = () => {
            const selectedSlug = effectSelect.value;
            socket.send(JSON.stringify({ type: "add_effect", data: { slug: selectedSlug } }));
        };
    }

    function renderEffect(effect) {
        const div = document.createElement("div");
        div.className = "effect-block";
        div.innerHTML = `<h3>${effect.slug}</h3>`;

        effect.parameters.forEach(param => {
            const row = document.createElement("div");

            if (param.definition.type === "slider") {
                const label = document.createElement("label");
                label.textContent = `${param.definition.name}: ${param.definition.default}`;

                const input = document.createElement("input");
                input.type = "range";
                input.min = param.definition.min;
                input.max = param.definition.max;
                input.value = param.definition.default;
                input.step = (param.definition.max - param.definition.min) / 100;;

                input.oninput = () => {
                    label.textContent = `${param.definition.name}: ${input.value}`;
                    sendParameterChange(param.uuid, parseFloat(input.value));
                };

                row.appendChild(label);
                row.appendChild(input);
            }

            if (param.definition.type === "switch") {
                const label = document.createElement("label");
                label.textContent = `${param.definition.name}: `;

                const select = document.createElement("select");
                for (const [key, val] of Object.entries(param.definition.allowedValues)) {
                    const opt = document.createElement("option");
                    opt.value = val;
                    opt.textContent = key;
                    if (parseFloat(val) === param.definition.default) {
                        opt.selected = true;
                    }
                    select.appendChild(opt);
                }

                select.onchange = () => {
                    sendParameterChange(param.uuid, parseFloat(select.value));
                };

                row.appendChild(label);
                row.appendChild(select);
            }

            div.appendChild(row);
        });

        effectsContainer.appendChild(div);
    }

    function sendParameterChange(uuid, value) {
        socket.send(JSON.stringify({
            type: "set_param",
            data: { uuid, value }
        }));
    }
</script>
</body>
</html>
